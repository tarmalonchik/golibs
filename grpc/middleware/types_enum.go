// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package middleware

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// ContextKeyAuthorization is a ContextKey of type authorization.
	ContextKeyAuthorization ContextKey = "authorization"
	// ContextKeyUsername is a ContextKey of type username.
	ContextKeyUsername ContextKey = "username"
)

var ErrInvalidContextKey = errors.New("not a valid ContextKey")

// ContextKeyValues returns a list of the values for ContextKey
func ContextKeyValues() []ContextKey {
	return []ContextKey{
		ContextKeyAuthorization,
		ContextKeyUsername,
	}
}

// String implements the Stringer interface.
func (x ContextKey) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ContextKey) IsValid() bool {
	_, err := ParseContextKey(string(x))
	return err == nil
}

var _ContextKeyValue = map[string]ContextKey{
	"authorization": ContextKeyAuthorization,
	"username":      ContextKeyUsername,
}

// ParseContextKey attempts to convert a string to a ContextKey.
func ParseContextKey(name string) (ContextKey, error) {
	if x, ok := _ContextKeyValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ContextKeyValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ContextKey(""), fmt.Errorf("%s is %w", name, ErrInvalidContextKey)
}

const (
	// TypeNone is a Type of type none.
	TypeNone Type = "none"
	// TypeBasic is a Type of type basic.
	TypeBasic Type = "basic"
)

var ErrInvalidType = errors.New("not a valid Type")

// TypeValues returns a list of the values for Type
func TypeValues() []Type {
	return []Type{
		TypeNone,
		TypeBasic,
	}
}

// String implements the Stringer interface.
func (x Type) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Type) IsValid() bool {
	_, err := ParseType(string(x))
	return err == nil
}

var _TypeValue = map[string]Type{
	"none":  TypeNone,
	"basic": TypeBasic,
}

// ParseType attempts to convert a string to a Type.
func ParseType(name string) (Type, error) {
	if x, ok := _TypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Type(""), fmt.Errorf("%s is %w", name, ErrInvalidType)
}
